### virtual 关键字

virual 是虚，虚拟的含义。c++ 中关键字"virual"主要用于两个方面：虚函数  和  虚基类。

### 1 虚函数

虚函数用于C++的类继承，是一种多态的一种。在C++中，一个基类的指针或者引用，可以指向或者引用派生类对象。 同时派生类可以重写基类中的成员函数。这里" 重写 " 要求是函数的特征标（包括参数的数目，参数类型，参数顺序）以及返回值 都必须与基类中的函数一致。

```C++
#include <iostream>

using namespace std;
class base {
private:
	int a, b;
public:
	virtual void test() {
		cout << "基类方法\n";
	}
	virtual ~base() {};
};

class inheriter :public base {
public:
	void test() {
		cout << "派生类方法\n";
	}
};


int main() {

	base *p1 = new base;
	base *p2 = new inheriter();
	p1->test();
	p2->test();
	int k;
	cin >> k;
	return 0;
}

```

可以在基类中将被重写的成员函数设置为**虚函数**

其含义是：当通过基类的指针或者引用调用该成员函数时，将根据指针指向的对象类型确定调用的函数，而非指针的类型。如下，是未将test()函数设置为虚函数前的执行结果： 

说明：

1.只需将类中的成员函数声明为虚函数 即可，派生类中重写的virtual 函数自动称为虚函数；

2.基类中的析构函数必须为虚函数，否则就会出现对象释放错误。以上例说明，如果不将 基类的析构函数 声明为virtual,

那么在调用delete  p2; 语句时将调用基类的析构函数，而不是应当调用的派生类的析构函数，从而出现对象释放错误的问题。

3.虚函数 的使用将导致类对象占用更大的内存空间。对于这一点的解释设计虚函数的调用原理问题：编译器给每一个**包括虚函数对象**添加了一个隐藏成员：指向虚函数表指针。 虚函数表（virtual function table） 包含了虚函数的地址，由所有虚函数对象共享。当派生类从新定义虚函数时，则将该函数的地址添加到虚函数表中。无论一个类对象中定义了多少个虚函数，虚函数指针只有一个。相应的，每个对象在内存中的大小要比没有虚函数时大4个字节（32位主机，不包括虚析构函数）。如下：

```C++
	cout << sizeof(base) << "\n";
	cout << sizeof(inheriter) << "\n";
```

base类中包括了两个整型的成员变量，各占4个字节大小，再加上一个虚函数指针，共计占12个字节；

inheriter类继承了base类的两个成员变量以及虚函数表指针，因此大小与基类一致。如果inheriter多重继承自另外一个也包括了虚函数的基类，那么隐藏成员就包括了两个虚函数表指针。 

4.重写函数的特征标必须与基类函数一致，(注释：这边看不懂){否则将覆盖基类函数}；

5.重写不同于重载。我对重载的理解是：同一个类，内部的同名函数具有不同的参数列表称为重载；重写则是派生类对基类同名函数的“本地改造”，要求函数特征标完全相同。当然，返回值类型不一定相同（可能会出现返回类型协变的特殊情况）。

### 2  虚基类

在C++ 中，派生类可以继承多个基类。问题在于：如果这多个基类又是继承自同一个基类时，那么派生类是不是需要多次这个

"同一个基类" 中的内容？ 虚基类可以解决这个问题。

简而言之，虚基类可以使得从多个类（它们继承自一个类） 中派生出的对象只继承一个对象。虚继承的写法可以如下：

```C++
   cout<<sizeof(mytest)<<endl;                  //输出12
   cout<<sizeof(myTest2)<<endl;                 //输出12
   cout<<sizeof(myTest3)<<endl;                 //输出16，若在base中添加一个int型成员，则输出20 mytest类与myTest2类的大小为什么是12？这是因为它们在虚继承自base类后，添加了一个隐藏的成员——指向虚基类的指针，占4个字节。
```

而base类本身占8个字节，因此它们的大小均为12。而对非虚继承而言，是不需要这样的一个指针的。而mytest3类的大小为sizeof(base)+sizeof(mytest-base)+sizeof(mytest2-base)，即16。 

**说明：**

1.若一个类多重继承自具有同一个基类的派生类时，调用同名成员函数时会出现二义性。**为了解决这个问题，可以通过作用域解析运算符澄清，或者在类中进行重新定义；**

2.继承关系可能是非常繁复的。一个类可能多重继承自别的类，而它的父类也可能继承自别的类。当该类从不同的途径继承了两个或者更多的同名函数时，如果没有对类名限定为virtual，将导致二义性。当然，如果使用了虚基类，则不一定会导致二义性。编译器将选择继承路径上“最短”的父类成员函数加以调用。该规则与成员函数的访问控制权限并不矛盾。也就是说，不能因为具有更高调用优先级的成员函数的访问控制权限是"private"，而转而去调用public型的较低优先级的同名成员函数。

> 关键字：最短路径

### 3 纯虚函数

若一个类的成员函数被声明为纯虚函数,则意味着该类是ABC(Abstruct Base Class ，抽象基类 ) ， 即只能被继承，而不能用来声明对象。纯虚函数通常要在类声明的后面加上关键词"=0"。


