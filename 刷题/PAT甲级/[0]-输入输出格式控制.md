---

---

- 输入输出格式
- 2019-7-19
- 

首先说C++代码

```C++
	#include <iomanip>  //不要忘了头文件

	//第一种写法
	cout<<setiosflags(ios::fixed)<<setprecision(2);

	//第二种写法
	cout.setf(ios::fixed);
	cout<<setprecision(2);

	//第三种写法
	cout<<fixed<<setprecision(2);
```


要保留几位小数setprecision(n)的括号里n就换成几。


要保留几位小数setprecision(n)的括号里n就换成几。

前两种写法是一样的，第三种是简化写的。

上面的语句写一次就行了，对之后的数字都有效。
##　　然后说C的代码
　　最近了解了一下C语言的输出，毕竟我一个C++入门的人，看不懂C语言的输出hhhhh，可能因为我比较差吧。个人感觉c的输出比较简单粗暴。

%f 格式化输出浮点型数据，在%之后加上“.n”即可。例如：

```C++
#include  <stdio.h>
int main()
{
	float PI=3.1415926;
	float R=5.3;
	printf("面积 = %.2f\n", PI * R * R); //输出：面积 = 88.25
	printf("面积 = %f\n", PI * R * R);   //输出：面积 = 88.247337
	printf("面积 = %.8f\n", PI * R * R); //输出：面积 = 88.24733734
        return 0;
}

%.2f\n中的“.2”即保留两位小数
//不设定保留几位小数，则默认六位
```



## 默认变量赋值：

> 编译器的默认方式进行初始化 （若是全局静态区存储变量，默认初始化为0，如果是栈上的局部变量，默认初始化为随机值）；

## 结构体的初始化

结构体是常用的自定义构造类型，是一种很常见的数据打包方法。结构体对象的初始化有多种方式，分为指定初始化、顺序初始化、构造函数初始化。

（1）指定初始化（Designated Initializer）实现上有两种方式，一种是通过点号加赋值符号实现，即“.fieldname=value”，另外一种是通过冒号实现，即“fieldname:value”，其中fieldname为指定的结构体成员名称。前一种是C99标准引入的结构体初始化方式，但在C++中，很多编译器并不支持。

　与数组一样，C++也支持将列表初始化用于结构，且等号（=）是可选的

```C++
//点号+赋值符号
struct A a={.b = 1,.c = 2};

//
struct A a={b:1,c:2}；

```

（2）顺序初始化是我们最常用的初始化方式，因为书写起来较为简约，但相对于指定初始化，无法变更初始化顺序，灵活性较差。

```C++
struct A a1={1,2};
```

（3）构造函数初始化常见于C++代码中，因为C++中的struct可以看作class，结构体也可以拥有构造函数，所以我们可以通过结构体的构造函数来初始化结构体对象。给定带有构造函数的结构体：

```C++
struct A 
{
	A(int a,int b)
	{
		this->a=a;
		this->b=b;
	};
	int b;
	int c;
}

```

那么结构体对象的初始化可以像类对象的初始化那样，如下形式：

```c++
struct A a(1,2);
```

**注意：** struct 如果定义了构造函数的话，就不能用大括号进行初始化了，即不能再使用指定初始化与顺序初始化了。

## 结构体的赋值

分别赋值，直接赋值，还可以用{}赋值。











如果单纯会用就行，看到这里就可以了！
--------------------- 
