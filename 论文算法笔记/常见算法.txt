~~~java
 /*分治算法 归并排序*/
 void merge_sort(int a[], int tmp[], int start, int end) {
    if (start < end) {
        int mid = (start + end) / 2;
        merge_sort(a, tmp, start, mid);
        merge_sort(a, tmp, mid + 1, end);
        merge(a, tmp, start, mid, end);
    }
}
void merge(int[] a, int tmp[], int start, int mid, int end) {
    int i = start, j = mid + 1, k = start;
    while (i < mid + 1 && j < end + 1) {
        if (a[i] < a[j])
            tmp[k++] = a[i++];
        else
            tmp[k++] = a[j++];
    }
    while (i < mid + 1) tmp[k++] = a[i++];
    while (j < end + 1) tmp[k++] = a[j++];
    for (k = start; k < end + 1; k++)
        a[k] = tmp[k];
}
/*分治算法，求数组逆序数*/
int inversionCount(int a[], int tmp[], int start, int end) {
    if (start < end) {
        int mid = (start + end) / 2;
        int leftCount = inversionCount(a, tmp, start, mid);
        int rightCount = inversionCount(a, tmp, mid + 1, end);
        int cossCount = crossCount(a, start, mid, end);
        merge(a, tmp, start, mid, end);
        //统计跨域逆序数,主要思路是统计完跨域逆序数之后，将两个merge为有序数组（）
        return leftCount + rightCount + cossCount;
    }
    return 0;
}
int crossCount(int a[], int start, int mid, int end) {
    int i = start, j = mid + 1, k;
    int count = 0;
    while (i < mid + 1 && j < end + 1) {
        if (a[i] > a[j]) {
            count += mid + 1 - i;
            j++;
        } else
            i++;
    }
    return count;
}
/*最大堆算法*/
/*堆特点：是完全二叉树，操作包括插入，删除； 对于频繁获取最大值的操作*/
/*物理结构是顺序存储的，逻辑结构是树结构*/
/*构造最大堆最简单的方式，最后叶子节点开始重新构造*/
void maxHeapfy(int a[], int i) {
    //去子元素中最大值
    int max_index;
    //该子树，已是叶子节点，已经是最大堆;只判断，非叶子节点
    if (i <= (a.length - 1) / 2) {
        if (2 * i + 1 < a.length) {
            if (a[2 * i] > a[2 * i + 1]) {
                max_index = 2 * i;
            } else {
                max_index = 2 * i + 1;
            }
        } else
            max_index = 2 * i;
        if (a[i] < a[max_index]) {
            a[0] = a[i];
            a[i] = a[max_index];
            a[max_index] = a[0];
            maxHeapfy(a, max_index);
        }
        System.out.println(Arrays.toString(a));
    }
}
int[] buildMaxHeap(int a[]) {
        int b[] = new int[a.length + 1];
        for (int i = 0; i < a.length; i++)
            b[i + 1] = a[i];
        //自下而上构造，最大堆;
        for (int i = a.length / 2; i >= 1; i--)
            maxHeapfy(b, i);
        return b;
}
//非递归
void maxHeapInitial(int a[], int len) {
    for (int i = len / 2; i >= 1; i--) {
        a[0] = a[i];
        int c = i * 2; //记录最小子节点下标，c/2就是其根节点
        while (c <= len) {
            if (c + 1 < len + 1 && a[c] < a[c + 1])
                c = c + 1;
            if (a[0] > a[c])
                break;
            a[c / 2] = a[c]; //上移
            c *= 2;//继续去其子节点
        }
        a[c / 2] = a[0];
    }
}
//最大堆插入算法,可以简单的递归调用heapfy函数
//其实就是找到不满足的父元素下移
void maxHeapInsert(int a[], int len, int num) {
    if (a.length == len + 1) {
        int b[] = new int[a.length * 2];
        for (int i = 0; i < a.length; i++) {
            b[i] = a[i];
        }
    }
    len++;
    int c = len;
    while (c != 1) {
        if (a[c / 2] > num)
            break;
        a[c] = a[c / 2];
        c /= 2;
    }
    a[c] = num;
}
int maxHeapDelete(int a[], int len) {
    //删除
    a[0] = a[1];
    a[1] = a[len--];
    int t = a[1];
    int c = 2;
    while (c < len) {
        if (a[c + 1] > a[c])
            c++;
        if (t > a[c])
            break;
        a[c / 2] = a[c];
        c *= 2; //继续判断子树
    }
    a[c / 2] = t;
    return a[0];
}
/*最大堆总结使用*/
/*使用举例子：k个数组已排好序[->]，每个n个元素 的排序*/
/*方式一：直接组合起来用快速排序，nk*log(nk)   ===>  O(nk*log(nk))  */
/*方式二：每次取一个最小值（复杂度为k），需要取n*k次 ===> O(nk^2) */
/*方式三：将k个元素构建成为最小堆，，每次取其最小值 {注意：构建一个堆的时间复杂度是O(n)  }===>  O(k+nk*log(k))  */
/*排序算法 */
void bubbleSort(int a[]) {
    for (int i = 0; i < a.length - 1; i++) {
        boolean flag = true;
        for (int j = 0; j < a.length - i - 1; j++) {
            if (a[j] > a[j + 1]) {
                int t = a[j];
                a[j] = a[j + 1];
                a[j + 1] = t;
                flag = false;
            }
        }
        if (flag) {
            break;
        }
    }
}
/*选择排序0(n^2)*/
void selectedSort(int a[]) {
    for (int i = 0; i < a.length - 1; i++) {
        int min_index = i;
        for (int j = i + 1; j < a.length; j++)
            if (a[j] < a[min_index])
                min_index = j;
        int t = a[min_index];
        a[min_index] = a[i];
        a[i] = t;
    }
}
/*插入排序0(n^2)*/
void insertSort(int a[]) {
    for (int i = 1; i < a.length; i++) {
        int t = a[i];
        int j;
        for (j = i - 1; j >= 0 && t < a[j]; j--) {
            a[j + 1] = a[j];
        }
        a[j + 1] = t; //停在比t大的元素上
    }
}
/*线性时间排序，计数排序+基数排序*/
/*1.计数排序，主要用于小整数位置保持不变，线性时间0(n)*/
int[] countSort(int a[]) {
    int max = a[0];
    //消耗时间n
    for (int i = 1; i < a.length; i++) {
        if (a[i] > max)
            max = a[i];
    }
    int c[] = new int[max + 1];
    //消耗时间n
    for (int i = 0; i < a.length; i++)
        c[a[i]]++; //计数
    //统计前面有多少个
    for (int i = 1; i < c.length; i++)
        c[i] += c[i - 1];
    int ranked[] = new int[a.length];
    for (int i = a.length - 1; i >= 0; i--) {
        ranked[--c[a[i]]] = a[i];
    }
    return ranked;
}
/*2.基数排序，从低位到高位 大整数  0(kn)=>O(n)*/
void radixSort(int a[], int d) {//d表示最大的数有几位
    int m = 1; //第几位
    int[][] temp = new int[10][a.length];
    int[] order = new int[10];//记录没一个列里元素个数
    int n = 1;
    while (m <= d) {
        //将每个对象放进各列中
        for (int i = 0; i < a.length; i++) {
            int value = (a[i] / n) % 10;
            temp[value][order[value]++] = a[i];
        }
        int j = 0;
        for (int i = 0; i < 10; i++) {
            if (order[i] != 0) {
                int k = 0;
                while (order[i] > k) {
                    a[j++] = temp[i][k++];
                }
                order[i] = 0;
            }
        }
        n *= 10;
        m++;
    }
}
/*动态规划算法{dynamic programming}*/
/*解决动态规划问题的几个子步骤：*/
/*1.定义子问题{prefix,suffix,infix}{前,中,后}：#sub problem:____*/
/*2.猜测一部分解 #guess:____*/
    /*#choice:_____*/
/*3.建立子问题递归*/
/*4.可以自低向下实现问题(包括原问题的解)*/
/*5.确定原问题的解*/
/*案例：1 菲波那切数列*/
int fibo_1(int n){
    if(n==1||n==2)
        return 1;
    else
        return fibo_1(n-1)+fibo_1(n-2);
}
int num[]=new int[1000000];
int len=0;
/*递归方式实现，优化了不少，将算出来的结果先存储*/
int fibo_2(int n){
    if(n>len){
        if(n<=2){
            num[n]=1;
            return num[n];
        }
        else{
            num[n]=fibo_2(n-1)+fibo_2(n-2);
            return  num[n];
        }

```
}
return num[n];
```

}
int fibo_3(int n){
    int dp[]=new int[n+1];
    dp[0]=dp[1]=1;
    for(int i=3; i<=n; i++){
        dp[i]=dp[i-1]+dp[i-2];
    }
    return dp[n];
}

/*大整数怎么处理，拓扑排序怎么处理？=小问题*/

/*案例2：最长递增子序列*/
/*Input {9,4,7,3,6,8,2}*/
/*Output:{4,6,8}|{3,6,8}*/

/*方案1:穷举法：穷举子序列*/
/*可以用二进制法：0->2^n*/

/*方案2：动态规划*/
/*定义子问题：prefix dp[0：i]表示已i下标结尾的为结束最长子序列长度*/
/*猜测:上一个元素的位置*/
/*#choice：0~i-1*/
/*递归定义子问题*/
/*dp[j]=max{dp[i]+1} &&a[j]>a[i]*/
 void longestSubSequese(int a[], List b[], int dp[]){
    int tmp[]=new int[a.length+1];
    for(int i=0; i<a.length; i++)
        tmp[i+1]=a[i];
    tmp[0]=Integer.MIN_VALUE;
    //int dp[]=new int[a.length+1];
    dp[0]=0;
    b[0]=new ArrayList();
    for(int i=1; i<tmp.length;i++){
        int max=dp[0];
        b[i]=new ArrayList();
        // int prev=0;
        for(int j=i-1; j>=0; j--){
            if(tmp[i]>tmp[j]&&dp[j]>max){
                max=dp[j];
                //  prev=j;
            }
        }
        for(int j=i-1; j>=0; j--){
            if(tmp[i]>tmp[j]&&dp[j]==max){
                b[i].add(j);
            }
        }
        dp[i]=max+1;
    }
    System.out.println(Arrays.toString(dp));
}
/*占时还有点问题*/
void displayLongestSubSequese(int a[],List b[],int k){
    for(Iterator it=b[k].iterator(); it.hasNext(); ){
        Integer t=(Integer) it.next();
        displayLongestSubSequese(a,b,t);
    }
    if(k!=0)System.out.print(a[k-1]+" ");
    else
        System.out.println();
}
/*案例3：空中接龙问题：{牌面相同，花色相同，"8"}可以连接， 求最长相连的排长度*/
/*定义子问题：prefix dp[0：i]表示已i下标结尾的为结束最长相连牌长度*/
/*猜测:上一个元素的位置*/
/*#choice：0~i-1*/
/*递归定义子问题*/
/*dp[j]=max{dp[i]+1}&& a[j]^a[i] 花色一样 || 牌面相同 || a[i] 是8*/
void solitaire(int a[],int dp[]){
    dp[0]=0;
}
/*案例4：n个硬币一行，不相邻和最大的序列*/
/*定义子问题：prefix dp[0:i]表示，{以a[i]为结尾}前i个元素最大值*/
/*猜测：0~i-1*/
/*递归子问题：dp[j]=max{dp[i]+A[j]}*/

/*思路2：*/
/*定义子问题：prefix dp[0：i]表示，前i个元素最大值*/
/*dp[i]=max{dp[i-1],dp[i-2]+a[i]}  注意在如果prev对应的前者是不捡的情况则*/
/*计算过程比较简单*/
int biggestSum(int a[],int prev[],int dp[]){
    prev[0]=prev[1]=-1;
    dp[0]=a[0];dp[1]=a[1];
    if(a[0]>a[1]){
        prev[1]=0;
        dp[1]=a[0];
    }
    for(int i=2; i<a.length; i++){
        int x=dp[i-1];
        int y=a[i]+dp[i-2];
        if(x>=y){
            dp[i]=x;
            int k=i-1;
            while(prev[k]!=-1&&dp[k]==dp[prev[k]]){
                k=prev[k];
            }
            prev[i]=k;
        } else{
            dp[i]=y;
            int k=i-2;
            while(prev[k]!=-1&&dp[k]==dp[prev[k]]){
                k=prev[k];
            }
            prev[i]=k;
        }
    }
    return dp[a.length-1];
}

/*案例4：连续累加和最大问题*/
/*解法同上*/

/*指定宽度文档，文字排版问题 */
/*定义子问题：前缀dp  [1~i) 前i个元素的子序列 ，从哪个位置开启newline dp[i]=min{dp[j]+badines(j:i)} */
/*猜测：从哪里开始第二行*/
/*# choice 选项：1~i 可以在一下任意个单词重起一行*/
/*badiness=(pageWidth-totalWidth)^3 pageWidth> totalWidth   */
/*pageWidth < total Width 是设置badiness为-无穷，避免出现这种情况*/

/*指定传进来的时候，就是0位置为空比较好*/
int wordFitness(int a[],int n,int dp[],int prev[]){
    int pageWidth=15;
    dp[0]=0;
    prev[0]=-1;
    for(int i=1; i<=n; i++){
        dp[i]= Integer.MAX_VALUE;
        for(int j=1; j<=i; j++){
            int totoalWith=0;
            for(int k=j; k<=i;k++){
                totoalWith+=a[k];
            }
            int badiness=Integer.MAX_VALUE-pageWidth*pageWidth*pageWidth;
            if(pageWidth>totoalWith){
                badiness=(pageWidth-totoalWith)*(pageWidth-totoalWith)*(pageWidth-totoalWith);
            }
            if(dp[j-1]+badiness<dp[i]){
                dp[i]=dp[j-1]+badiness;
                prev[i]=j;
            }
        }
    }
    return dp[n];
}
/*案例5：最长回文子序列符串*/
/*中缀表达式：middle*/
/* dp[i][j]=max{ a[i]==a[j]: dp[i+1][j-1]+2;  a[i]!=a[j]:dp[i+1][j],dp[i]dp[j-1] }  */
int longgestSubHuiwenSequese(char a[]) {
    int dp[][] = new int[a.length][];
    for (int i = 0; i < a.length; i++) {
        dp[i] = new int[a.length];
    }
    //init
    for (int i = 0; i < a.length; i++)
        dp[i][i] = 1;
    //斜线
    for (int c = 1; c < a.length; c++) {
        for (int i = 0, j = c; i < a.length && j < a.length; i++, j++) {
            int max = -1;
            if (a[i] == a[j] && j > i + 1) {
                if (dp[i + 1][j - 1] + 2 > max) {
                    max = dp[i + 1][j - 1] + 2;
                }
            }
            if (dp[i + 1][j] > max) {
                max = dp[i + 1][j];
            }
            if (dp[i][j - 1] > max) {
                max = dp[i][j - 1];
            }
            dp[i][j] = max;
        }
    }
    return dp[0][a.length - 1];
}
/*案例5：矩阵乘法,a*b  b*c =复杂度是 a*c*b  */
/*dp[i][j]=min{dp[i][k-1]+dp[k][j]+a[i][0]*a[j][1]*a[k-1][1] }*/
int matrixChenfa(int matrix[][]){
    int dp[][]=new int[matrix.length][];
    int prev[][]=new int[matrix.length][];
    for(int i=0; i<matrix.length; i++){
        dp[i]=new int[matrix.length];
        //dp[i][i]=0;
        prev[i]=new int[matrix.length];
    }
    for(int c=1; c< matrix.length; c++){
        for(int i=0,j=c; i<matrix.length&&j<matrix.length; i++,j++){
            int min=Integer.MAX_VALUE;
            prev[i][j]=-1;
            for(int k=i+1;k<=j; k++){
                int cur=dp[i][k-1]+dp[k][j]+matrix[i][0]*matrix[j][1]*matrix[k][0];
                if(cur<min) {
                    min = cur;
                    prev[i][j]=k;
                }
            }
            dp[i][j]=min;
        }
    }
    int path=matrix.length;
    display(0,matrix.length-1,prev);
    return dp[0][matrix.length-1];
}
void display(int start,int end,int prev[][]){
    int split=prev[start][end];
    if(split!=0){
        display(start,split-1,prev);
        display(split,end,prev);
    }
    System.out.println(split);
}
/*案例6：0-1背包问题*/
/*子问题：prefix  dp[i][j] i是前n件物品，当前背包剩余容量*/
/*递推关系式：dp[i][j]=max{dp[i-1][j-wj]+v[j],dp[i-1][j]}*/
void zeroOnePackage(int beibao,int w[],int v[]){
    int dp[][]=new int[w.length+1][];
    for(int i=0; i<w.length+1;i++){
        dp[i]=new int[beibao+1];
    }
    for(int i=1; i<=w.length; i++){
        for(int j=1; j<=beibao; j++){
            int add=0;
            if(j>w[i-1]) {
                    add = dp[i - 1][j - w[i-1]] + v[i-1];
            }
            int notAdd = dp[i - 1][j];
            dp[i][j] = add > notAdd ? add : notAdd;
        }
    }
}
/*搜索算法：回溯问题*/
int number=0;
int column[]=new int[8];
int lup[]=new int[2*8-1];
int rup[]=new int[2*8-1];
int queens[]=new int[8];
/*n皇后问题：dfs,回溯法*/
void trackback(int i){
    if(i>=8){
        number++;
    } else{
        for(int j=0; j<8; j++){
            if(column[j]!=1&&lup[i-j+8-1]!=1&&rup[i+j]!=1){
                column[j]=1;
                lup[i-j+8-1]=1;
                rup[i+j]=1;
                queens[i]=j;
                trackback(i+1);
                column[j]=0;
                lup[i-j+8-1]=0;
                rup[i+j]=0;
            }
        }
    }
}
/*宽度优先，分支限界法*/
/*队列式(FIFO)分支限界法:按照队列先进先出（FIFO）原则选取下一个结点为扩展结点。
    优先队列式分支限界法 :按照优先队列中规定的优先级选取优先级最高的结点成为当前扩展结点。*/
int wt[]=new int[]{8,6,3,2};
int n=4;
int c=7;
int bfs(){
    int i=0;
    Queue<Integer> queue=new LinkedList<Integer>();
    queue.add(-1);
    int curW=0;
    int bestW=0;
    while(true){
        //先添加
        if(wt[i]+curW<=c){
            if(i==n-1&&wt[i]+curW>bestW){//叶子节点
                bestW = wt[i] + curW;
            }
            if(i<n-1) //非叶子节点加入队列
                queue.add(wt[i]+curW);
        }
        else {
            if(i==n-1&&curW>bestW) { //叶子节点
                bestW = curW;
            }
            if(i < n - 1)  //非叶子节点
                queue.add(curW);
        }
        curW = queue.poll(); //获取头部
        if(curW==-1){
            if(queue.isEmpty()) return bestW;
            queue.add(-1);//末尾添加分层标志
            curW=queue.poll();//删除头部分层标志
            i++; //进入下一层
        }
    }
}

//1.归并排序
int a[] = new int[]{50, 10, 20, 30, 70, 40, 80, 60};
int b[] = new int[8];
/*merge_sort(a,b,0,7);*/
//2.逆序数对数目
inversionCount(a, b, 0, 7)
//3.最大堆
buildMaxHeap(a);
int heapInit[] = new int[]{0, 50, 10, 20, 30, 70, 40, 80, 60};
int len = 8;
maxHeapInitial(heapInit, len);
//最大堆删除
int top = maxHeapDelete(heapInit, len);
len--;
//最大堆插入
maxHeapInsert(heapInit, len, 89);
len++;
/*最长子序列*/
int arr6[]=new int[]{9,4,7,3,6,8,2}; //实际元素从1开始
List prev[]=new List[arr6.length+1];
int dp[]=new int[arr6.length+1];

longestSubSequese(arr6,prev,dp);

int max_index=0;
for(int i=1; i<dp.length ;i++){
    if(dp[i]>dp[max_index]){
        max_index=i;
    }
}

int cur=max_index;
int subSequese[]=new int[arr6.length];
displayLongestSubSequese(arr6,prev,max_index);

/*n个硬币，不可连续取其最大值*/
int arr7[] =new int[]{0,5,1,2,10,6,2};
int prev1[]=new int[arr7.length];
int dp2[]=new int[arr7.length];
int biggestSum=biggestSum(arr7,prev1,dp2);
int t1=0;
for(int i=1;i<dp2.length; i++){
    if(dp2[i]>dp2[t1])
        t1=i;
}
while(t1!=-1){
    System.out.print(t1);
    t1=prev1[t1];
}
/*"---最优文本排版---"*/
int arr8[] =new int[]{0,5,5,5,5,14};
int prev8[]=new int[arr8.length];
int dp8[]=new int[arr8.length];
int len8=5;
int k=wordFitness(arr8,len8,dp8,prev8);
/*"最长的回文子字符串的长度"*/
int k8=len8;
while(k8 !=-1){
    System.out.print(k8+" ");
    k8=prev8[k8-1];
}
System.out.println();
/*最长回文子字符串*/
char arr9[]="character".toCharArray();
int len9=longgestSubHuiwenSequese(arr9);
/*"矩阵乘法最小复杂度*/
int arr10[][]=new int[][]{{20,25},{25,15},{15,5},{5,12}};
int len10=matrixChenfa(arr10);
/*0-1背包问题*/
int v[]=new int[]{8,10,6,3,7,2};
int w[]=new int[]{4,6,2,2,5,1};
int bag=12;
zeroOnePackage(bag,v,w);
/*n皇后问题*/
Fuxi test=new Fuxi();
test.trackback(0);
/*宽度优先船最大装载问题*/
int bestW=test.bfs();
~~~

