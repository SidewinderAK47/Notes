# 42.Trapping Rain Water

Hard   

> 注意这是字节跳动原题。

Given *n* non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.

![img](Untitled.assets/rainwatertrap.png)
The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. **Thanks Marcos** for contributing this image!

**Example:**

```
Input: [0,1,0,2,1,0,1,3,2,1,2,1]
Output: 6
```

## 题目描述：

题目描述起来还是比较简单的，就是上述这结构最多能够，容纳多少雨水的问题。

> 自己的想法存在一点漏洞，会进入死循环。所以直接借用了网上的解法。

题目解答：

解法技术：双指针

解法思路：最外层左右两边的高度是该容器容量的下限：内部有比它低的 一减就是容量。超过这个高度的话，就保持为当前最高高度。

左右指针，每次移动高度较小的一段的指针。（因为容量取决于最低的高度）:happy:

 :+1:   移动指针过程中，没经过一个单位，

``` C++
class Solution {
public:
    int trap(vector<int>& height) {
        //我占时的思路：也许可以从两边移动到中间然后处理一下。
        //尝试一下
        //找到中间最高的点之一。然后往两边找最最大的点。
        int len=height.size(),ans=0;
        if(len<=2)  return 0;
        int l=0,r=len-1,lmax=height[l],rmax=height[r];
        l++;
        r--;
        while(l <= r){
             if(lmax<rmax){
                if(height[l]>lmax)
                    lmax = height[l];
                else
                    ans += (lmax-height[l]);
                l++;
             } 
             else{
                if(height[r]>rmax)
                    rmax=height[r];
                else
                    ans += (rmax-height[r]);
                r--;
             }
        }
        return ans;
    }
};
```

